---
title: "Final project"
author: "Reese Quillian"
output:
  html_document:
    df_print: paged
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Final Project Topic: Crime, Cybersecurity

Load datasets:
```{r}
library(tidyverse)
setwd("C:/Users/Student/OneDrive - University of Virginia/Desktop/SYS2202/Final/SYS2202-Final-repo")
```

```{r}
# Datasets

# complaints dataset
complaints <- read_csv("C:/Users/Student/OneDrive - University of Virginia/Desktop/SYS2202/Final/NYPD_Complaint_Data_Current__Year_To_Date_.csv")

# income dataset
income <- read_csv("C:/Users/Student/OneDrive - University of Virginia/Desktop/SYS2202/Final/Citywide_Payroll_Data__Fiscal_Year_.csv") 
```


## Question: How does the level of wealth in an area affect the frequency of crimes committed? 
## Sub-Question: What about the types of crimes being committed?

### Relevant variables

Complaints dataset: LAW_CAT_CD, BORO_NM

```{r}
complaints %>%
  dplyr::select(LAW_CAT_CD, BORO_NM) %>%
  glimpse()
```

LAW_CAT_CD and BORO_NM are both character variables. LAW_CAT_CD has 3 values: violation, misdemeanor, and felony. BORO_NM has 5 levels (there are 5 boroughs in NYC): Bronx, Brooklyn, Queens, Manhattan, and Staten Island.

Income dataset: Work Location Borough, Base Salary
```{r}
income %>%
  dplyr::select(`Work Location Borough`, `Base Salary`) %>%
  glimpse()
```
Base Salary is a numeric variable, that represents each persons salary. The salaries are recorded as either yearly, monthly, hourly, or prorated yearly.


#### missing values - pre cleaning
```{r}
complaints %>%
  filter(is.na(BORO_NM)) %>%
  count()
```

There are 1151 observations that are missing the name of the borough. This is only (approximately) 0.2% of all total complaints, so they will be removed. 

## Complaints Data

### Preliminary Data Cleaning
To clean the complaints data, we will start by filtering out all observations prior to 2018, and those missing the borough. Borough values are needed because this variable will be the key to joining the income and complaints datasets.
```{r}
# only look at complaints from after 2015
complaints <- complaints %>%
  filter(CMPLNT_FR_DT >= 1/1/2018) %>%
  # remove observations without a borough
  filter(!is.na(BORO_NM))
```

### Variables to examine: LAW_CAT_CD, BORO_NM

#### Visualize distributions (Barcharts, Histograms)

We will start by just looking at crimes by borough before factoring in income.

```{r}
complaints %>%
  group_by(BORO_NM) %>%
  summarize(count = n()) %>%
  ggplot(aes(x=reorder(BORO_NM, -(count)), y=count, fill=BORO_NM)) + 
  geom_bar(stat="identity") + 
  coord_flip() +
  theme(legend.position = "none") + 
  ggtitle("Number of Crime Complaints by Borough") + xlab("Borough Name")
```


It can be observed that the Bronx experiences the highest number of complaints in this dataset, and Staten Island the smallest. Though this is helpful in understanding the data, it will be more telling if the complaints are normalized by population:

```{r}
borough_populations = c(1472654, 2736074, 1694251, 2405464, 495747)
complaints %>%
  group_by(BORO_NM) %>%
  summarize(count = n()) %>%
  add_column(population = borough_populations) %>%
  mutate(crime_rate = count / population) %>%
  ggplot(aes(x=reorder(BORO_NM, -(crime_rate)), y=crime_rate, fill=BORO_NM)) +
  geom_bar(stat="identity") + 
  coord_flip() +
  theme(legend.position = "none") + 
  ggtitle("Crime Rates by Borough") + xlab("Borough Name")
```

From this, we see that Manhattan has the highest crime rate, followed by Bronx and Brooklyn. Staten Island and Queens still remain the lowest two, but the differences are less pronounced. 


Now we can look into the number of complaints by the level of offense (felony, misdemeanor, violation). First we will look at the distribution of LAW_CAT_CD using a bar graph.

```{r}
complaints %>%
  filter(!is.na(LAW_CAT_CD)) %>%
  group_by(LAW_CAT_CD) %>%
  summarize(count = n()) %>%
  ggplot(aes(x=reorder(LAW_CAT_CD, -(count)), y=count, fill=LAW_CAT_CD)) + 
  geom_bar(stat="identity") + 
  coord_flip() +
  theme(legend.position = "none") + 
  ggtitle("Number of Crime Complaints by Type") + xlab("Type")
```


```{r}
complaints %>%
  group_by(BORO_NM, LAW_CAT_CD) %>%
  summarize(count = n()) %>%
  
  ggplot(aes(x=reorder(BORO_NM, -(count)), y=count, fill=LAW_CAT_CD)) + 
  geom_bar(stat="identity") + 
  coord_flip() +
  ggtitle("Number of Crime Complaints by Borough \n and Level of Offense") +
  xlab("Borough Name")
```

Again, it is more useful to look at this graph using crime complaints normalized by populations:

```{r}
# each population is listed 3 times to correspond to the length of the dataframe when grouping by LAW_CAT_CD and BORO_NM
borough_populations = c(1472654, 1472654, 1472654, 2736074, 2736074, 2736074, 1694251, 1694251, 1694251, 2405464, 2405464, 2405464, 495747, 495747, 495747)
complaints %>%
  group_by(BORO_NM, LAW_CAT_CD) %>%
  summarize(count = n()) %>%
  add_column(population = borough_populations) %>%
  mutate(crime_rate = count / population) %>%
  ggplot(aes(x=reorder(BORO_NM, -(crime_rate)), y=crime_rate, fill=LAW_CAT_CD)) +
  geom_bar(stat="identity") + 
  coord_flip() +
  ggtitle("Crime Rates by Borough and Level of Offense") + xlab("Borough Name")
```
In both of the above graphs, the proportion of each category of crime appears to be approximately the same. In other words, higher crime rates do not imply a disproportionately higher level of a certain crime. 

Taking a closer look, it easier to see this proportions of each crime level in the boroughs: 

```{r}
complaints %>%
  group_by(BORO_NM, LAW_CAT_CD) %>%
  summarize(count = n()) %>%
  
  ggplot(aes(x=reorder(BORO_NM, -(count)), y=count, fill=LAW_CAT_CD)) + 
  geom_bar(position = "fill", stat="identity") + 
  coord_flip() +
  ggtitle("Number of Crime Complaints by Borough \n and Level of Offense") +
  xlab("Borough Name") + ylab("Percent")
```

## Income Data
  
### Variables to examine: Work Location Borough, Base Salary

#### Visualize distributions (Barcharts, Histograms)

Base Salary is listed in multiple different ways (yearly, monthly, hourly).
For this analysis, we will only be looking at annual salaries. Removing observations that are recorded on a monthly or hourly basis still leaves over 1 million observations, so lack of data is not an issue.

#### Data cleaning
Filter the income data to only include those actively working and those earning an annual salary. Unusual values will be dealt with later.

```{r}
income_annual <- income %>%
  # rename columns so they are easier to work with
  rename(boro = `Work Location Borough`, 
         salary = `Base Salary`, 
         basis = `Pay Basis`) %>%
  # we only want to look at individuals who are actively working, otherwise the   data will be skewed
  filter(`Leave Status as of June 30` == "ACTIVE") %>%
  filter(basis == 'per Annum') %>%
  filter(`Fiscal Year` >= 2018)
head(income_annual)
```

```{r}
# Distribution of annual salaries
income_annual %>%
  ggplot(aes(x=salary)) + 
  geom_histogram() + ggtitle("Distribution of Annual Salaries")
```

The histogram is right skewed, meaning there are some high outliers. These values may need to be removed/assigned a new value later in the analysis. 

```{r}
# Summary of income data; to be used to determine outliers
summarize(income_annual, median(salary), mean(salary), IQR(salary), sd(salary))
summary(income_annual$salary)
```


```{r}
# Determining outliers
income_annual %>%
  filter(salary > quantile(salary,0.75) + 1.5*IQR(salary))
```

Using the formula from before, all outliers will be removed from the dataset. Again, this still leaves plenty of data to work with. 

```{r}
# Removing outliers
income_annual <- income_annual %>%
  filter(salary < quantile(salary,0.75) + 1.5*IQR(salary))
```

Now we can observe the distribution of annual salaries without outliers:
```{r}
income_annual %>%
  ggplot(aes(x=salary)) + 
  geom_histogram() + ggtitle("Distribution of Annual Salaries")
```

There appears to be a large cluster whose salary is between $75,000 and $80,000.

The borough variable in the income dataset has different capitalizations, which need to be fixed so that it can be joined with the complaints data. This is done below.

```{r}
# Cleaning borough variable
library(stringr)
income_annual <- income_annual %>%
  mutate(BORO_NM = str_to_upper(boro)) %>%
  filter(BORO_NM == 'BRONX' | BORO_NM == 'BROOKLYN' | BORO_NM == 'QUEENS' |
         BORO_NM == 'MANHATTAN' | BORO_NM == 'RICHMOND') %>% 
  # Staten Island is also known as Richmond
  mutate_at('BORO_NM', str_replace, 'RICHMOND', 'STATEN ISLAND')
```

Now that the salary data and borough names have been cleaned, we can look at the distribution of salaries by borough:

```{r}
# Distribution by borough
income_annual %>%
  filter(salary > 0 && salary < quantile(salary,0.75) + 1.5*IQR(salary)) %>%
  ggplot(aes(x=salary, color = BORO_NM)) + 
  geom_freqpoly() + ggtitle("Distribution of Annual Salaries \n by Borough")
```
All boroughs appear to have a cluster between $75000 and $80000, as well as one around $45000. This may be due to a common position, or common salary for entry-level positions. 

## Covariation between variables
The two datasets need to be joined in order to analyze the relationship between income and crime.

```{r}
income_by_boro <- income_annual %>%
  group_by(BORO_NM) %>%
  summarize(median_salary = median(salary))
income_by_boro
```


```{r}
crime_by_boro <- complaints %>%
  group_by(BORO_NM) %>%
  summarize(count = n())


crime_counts_categories <- complaints %>%
  group_by(BORO_NM, LAW_CAT_CD) %>%
  summarize(count = n())
```


```{r}
# income and crime
income_and_crime <- income_by_boro %>%
  left_join(. , crime_by_boro, by = "BORO_NM") %>%
  rename(complaint_count = count) %>%
  arrange(desc(median_salary))
income_and_crime
```

```{r}
library(ggpubr)
cor.test(income_and_crime$median_salary, income_and_crime$complaint_count)
```

There is not a significant correlation between median_salary and complaint_count. This may be partly due to the small number of data point (5), since boroughs are such a large unit of analysis. For now, we will visualize the data using a map. Later, the analysis will be expanded to look into smaller regions of NYC in order to observe any relationship in more detail.

# Using geospatial data
```{r}
library(rgdal)
library(raster)
my_spdf <- shapefile("C:/Users/Student/OneDrive - University of Virginia/Desktop/SYS2202/Final/boro_shape_file/boro_shape_file.shp")
```
```{r}
library(broom)
# Tidying shape file
spdf_new <- tidy(my_spdf)

spdf_new <- spdf_new %>%
  mutate(id = recode(id, '0'='QUEENS', '1'='BROOKLYN', '2'='STATEN ISLAND', 
                     '3'='MANHATTAN', '4'='BRONX'))
```

```{r}
# Merge geospatial and numeric data
spdf_income <- spdf_new %>%
  left_join(. , income_by_boro, by=c("id"="BORO_NM"))
```

```{r}
# creating crime points to display on map
categories <- complaints %>%
  dplyr::select(LAW_CAT_CD, BORO_NM, Latitude, Longitude) %>%
  group_by(BORO_NM, LAW_CAT_CD) %>%
  summarize(across(.fns = mean)) %>%
  
  # need to add random numbers to Latitude or Longitude to see all points in plot:
  mutate(Longitude_random = Longitude + runif(length(Longitude), 
                                            min=0.001, max = 0.01)) %>%
  mutate(Latitude_random = Latitude + runif(length(Latitude), 
                                            min=0.001, max=0.025))

categories$count <- crime_counts_categories$count
head(categories)
```


```{r}
# Plot map & points
library(ggplot2)
ggplot() +
  geom_polygon(data = spdf_income, aes(fill = median_salary, x = long, y = lat, group = group)) + 
  theme_void() +
  coord_map() +
  labs(fill = "Median Salary") + 
  ggtitle("Boroughs of NYC by Median Salary and Crime Levels") + 
  geom_point(data=categories, aes(x=Longitude_random, y=Latitude_random, 
            color = LAW_CAT_CD, size = count), alpha = 0.75) + 
  scale_color_manual(values = c("#FF0000", "#E7B800", "#008000"))
```

### Zooming in: Using data by zip code

Median salary is not representative of all areas within each borough. For the next round of analysis, we will look into income & crime within each zip code in New York. 

```{r}
my_spdf1 <- shapefile("C:/Users/Student/OneDrive - University of Virginia/Desktop/SYS2202/Final/zipcode_shape_file/zipcodes.shp")
```


```{r}
spdf_zipcodes_new <- tidy(my_spdf1, zip="modzcta")
```

```{r}
# getting back zipcode after tidy()
temp_df <- data.frame(my_spdf1@data$modzcta)
names(temp_df) <- c("modzcta")
# create and append id
temp_df$id <- seq(0,nrow(temp_df)-1)

spdf_zipcodes_new <- spdf_zipcodes_new %>%
  mutate(id=as.integer(id)) %>%
  left_join(. , temp_df, by="id")
head(spdf_zipcodes_new)
```


```{r}
# income data by neighborhood to fill map:
zip_income <- read_csv("C:/Users/Student/OneDrive - University of Virginia/Desktop/SYS2202/Final/zip_code_income.csv")
```

Merge geospatial neighborhood data and income data:
```{r}
spdf_income_zipcode <- spdf_zipcodes_new %>%
  mutate(modzcta = as.double(modzcta)) %>%
  left_join(. , zip_income, by=c("modzcta"="zipcode")) %>%
  rename(median_household_income=`Median Household Income`)
head(spdf_income_zipcode)
```


```{r}
# Plot map 
library(ggplot2)
income_map <- ggplot() +
  geom_polygon(data = spdf_income_zipcode, aes(fill = median_household_income, x = long, y = lat, group = group)) + 
  theme_void() +
  coord_map() + 
  scale_fill_viridis_c(option = "H")
income_map + ggtitle("NYC Median Household Income by Zip Code")
```

Now, let's visualize crime along with income. First, we need to add a zip code column to the complaints data, then normalize the crime by population within each zip code. 

```{r}
library(sf)
crimes_loc <- complaints %>%
  dplyr::select(Latitude, Longitude)

# convert Lat_Lon to spatial data
# help from stackoverflow:
# https://stackoverflow.com/questions/64281070/checking-if-a-point-falls-within-polygon-shapefile
map = read_sf("C:/Users/Student/OneDrive - University of Virginia/Desktop/SYS2202/Final/zipcode_shape_file/zipcodes.shp")
map <- st_transform(map,crs=4326)

pnts_sf <- st_as_sf(crimes_loc, coords = c('Longitude', 'Latitude'), crs = st_crs(map))
pnts_trans <- st_transform(pnts_sf,crs=4326)
result <- sf::st_join(pnts_trans, map)
result <- result %>%
  rename(crime_location = geometry)
head(result)
```

Result dataframe includes the locations of the crime complaints with zipcodes. Before mapping, we will calculate the crime rate for each zipcode by dividing the number of complaints by the estimated population (which is data provided by the shape file).

```{r}
crime_count_zip <- result %>%
  group_by(modzcta) %>%
  summarize(count = n())
```

```{r}
crime_count_zip <- crime_count_zip %>%
  filter(!(is.na(modzcta))) %>% # income data was missing a few zip codes
  mutate(loc = st_centroid(crime_location)) %>%
  mutate(pop = map$pop_est) %>%
  mutate(crime_rate = count / pop)
head(crime_count_zip)

#Now we have the counts of crime in each zip code, the populations, and a central point to plot. 
```

Plot income & crime:

```{r}
# separate point objects into latitude and longitude for geom_point()
points <- as.data.frame(st_coordinates(crime_count_zip$loc))
crime_count_zip <- crime_count_zip %>%
  mutate(lon = points$X, lat = points$Y)

# create number of sizes to show
mybreaks <- c(0.1, 0.2, 0.4, 0.6)

income_map +
  geom_point(data=crime_count_zip, aes(x=lon,y=lat,size = crime_rate), fill="grey", alpha=0.3) + 
  scale_size_continuous(name="Crime Rate (complaints/population)", breaks=mybreaks) + 
  ggtitle("Income and Crime in New York City")
```

In addition to the map, we can check for a linear relationship between median household income (this time by zipcode) and crime rate.
crime rate is in the crime_count_zip dataframe, and income is in zip income:

```{r}
income_crime_corr <- zip_income %>%
  mutate(zip = as.character(zipcode)) %>%
  left_join(. , crime_count_zip, by=c("zip"="modzcta")) %>%
  dplyr::select(zip, `Median Household Income`, count, crime_rate)
head(income_crime_corr)

ggplot(income_crime_corr, aes(x=crime_rate, y=`Median Household Income`)) + 
  geom_point() + geom_smooth(method='lm', formula= y~x) + 
  stat_regline_equation(label.y = 225000, aes(label = ..eq.label..)) +
  stat_regline_equation(label.y = 210000, aes(label = ..rr.label..)) +
  ggtitle("Income vs. Crime Rate")

```

There is not a linear relationship between income and crime, when looking at the zipcodes of New York City.

```{r}
ggplot(income_crime_corr, aes(x=count, y=`Median Household Income`)) + 
  geom_point() + geom_smooth(method='lm', formula= y~x) + 
  stat_regline_equation(label.y = 225000, aes(label = ..eq.label..)) +
  stat_regline_equation(label.y = 210000, aes(label = ..rr.label..)) +
  ggtitle("Income vs. Crime Count")
```
The correlation is more apparent when looking at counts of crime (i.e. not normalizing for population).
